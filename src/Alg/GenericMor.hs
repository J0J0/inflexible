{-# LANGUAGE ScopedTypeVariables, TypeFamilies #-}

-- |
-- Module      : Alg.GenericMor
-- Description : Generic algebra morphisms
-- 
-- In this module, we provide /generic/ morphisms from one algebra to
-- another and deduce polynomial constraints for it being a dga morphism.
-- In more detail, this means the following:
-- 
-- Let \((A,d_A)\) and \((B,d_B)\) be cochain algebras over @k@, generated by \(a_1,\dots,a_r\) and
-- \(b_1,\dots,b_s\), respectively. A morphism of algebras \(A\to B\)
-- must map each \(a_i\) to a linear combination of monomials in the \(b_j\) of
-- the same degree, and each such choice for mapping the generators yields
-- a morphism (see also 'Alg.extendToAlg').
-- Abstracting over the coefficients, we may describe a /generic morphism \(f\)/ by the rules
-- \[ a_i \mapsto \sum_m T_{i,m} \cdot m \]
-- with \(m\) ranging over all monomials in \(B\) that are of the same degree as \(a_i\),
-- where the \(T_{i,m}\) are variables of a polynomial ring over @k@.
-- 
-- The equation \( d_B\circ f - f\circ d_A = 0 \), evaluated on the \(a_i\), determines
-- a finite number of polynomial equations in the \(T_{i,m}\).
-- A choice of substitution for the \(T_{i,m}\) in \(f\) determines
-- a dga morphism \((A,d_A)\to (B,d_B)\) if and only if it satisfies
-- this system of polynomial equations.

module Alg.GenericMor where

import Prelude hiding ( (*>), (<*) )
import qualified Data.Map.Strict as M
import qualified Data.Set as S
import Data.Traversable (mapAccumL)

import Math.Algebras.VectorSpace ((*>))
import Math.Algebras.Structures (unit)
import qualified Math.CommutativeAlgebra.Polynomial as Poly

import Types
import Alg
import HFMext (coeffs, changeBaseRing)

-- | Generate a generic morphism of algebras. The type of variables @v@
-- must be an 'Enum', from which the \(T_{\dots}\)-variables are sampled
-- (ascending and starting at "1").
genericAlgMor :: forall p k a b m v. (ENOO k a b, PolyRing k p m v, Enum v)
              => DgaSpec k a -> DgaSpec k b -> AlgMor p a b
genericAlgMor algA algB = extendToAlg (f M.!)
    where
        degs    = foldr S.insert S.empty (_gens algA)
        bases   = M.fromSet (findBasis_ (extendScalars algB)) degs :: M.Map Deg [Lam p b]
        (_, f)  = mapAccumL go (toEnum 1) (_gens algA)
        go v' i = foldl (\ (v,a) g -> (succ v, a + var v *> g)) (v',0) (bases M.! i)
        var     = Poly.var

-- | Based on 'genericAlgMor', this computes the polynomial constraints.
genericDgaMorConstraints :: forall p k a b m v. (ENOO k a b, PolyRing k p m v, Enum v)
                         => DgaSpec k a -> DgaSpec k b -> [p]
genericDgaMorConstraints dgaA dgaB = foldMap (coeffs . comm) (algGenerators dgaA)
    where
        f      = genericAlgMor dgaA dgaB            :: AlgMor p a b
        emb    = changeBaseRing unit                :: Lam k a -> Lam p a
        dA     = emb . _diff dgaA                   :: Lam k a -> Lam p a
        dB     = _diff (extendScalars dgaB)         :: Differential p b
        comm                                        :: Lam k a -> Lam p b
        comm x = dB (f (emb x)) - f (dA x)

-- | Specialization of 'genericDgaMorConstraints' where domain and codomain of
-- the morphism coincide.
genericDgaEndoConstraints :: forall p k m v a. (ENO k a, PolyRing k p m v, Enum v)
                          => DgaSpec k a -> [p]
genericDgaEndoConstraints dga = genericDgaMorConstraints dga dga
